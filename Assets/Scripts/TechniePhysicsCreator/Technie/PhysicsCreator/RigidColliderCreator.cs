using System.Collections.Generic;
using Technie.PhysicsCreator.Rigid;
using UnityEngine;

namespace Technie.PhysicsCreator
{
	public class RigidColliderCreator : MonoBehaviour, ICreatorComponent
	{
		public PaintingData paintingData;

		public HullData hullData;

		private List<HullMapping> hullMapping;

		private Mesh debugMesh;

		private void OnDestroy()
		{
		}

		public GameObject GetGameObject()
		{
			return base.gameObject;
		}

		public bool HasEditorData()
		{
			return paintingData != null;
		}

		public IEditorData GetEditorData()
		{
			return paintingData;
		}

		public void CreateColliderComponents(Mesh[] autoHulls)
		{
			CreateHullMapping();
			foreach (Hull hull in paintingData.hulls)
			{
				UpdateCollider(hull);
			}
			foreach (Hull hull2 in paintingData.hulls)
			{
				CreateAutoHulls(hull2, autoHulls);
			}
		}

		public void RemoveAllColliders()
		{
			if (hullMapping == null)
			{
				return;
			}
			foreach (HullMapping item in hullMapping)
			{
				DestroyImmediateWithUndo(item.generatedCollider);
				if (item.autoGeneratedColliders != null)
				{
					MeshCollider[] autoGeneratedColliders = item.autoGeneratedColliders;
					for (int i = 0; i < autoGeneratedColliders.Length; i++)
					{
						DestroyImmediateWithUndo(autoGeneratedColliders[i]);
					}
				}
			}
			for (int num = hullMapping.Count - 1; num >= 0; num--)
			{
				if (hullMapping[num].targetChild != null)
				{
					hullMapping.RemoveAt(num);
				}
			}
		}

		public void RemoveAllGenerated()
		{
			CreateHullMapping();
			foreach (HullMapping item in hullMapping)
			{
				DestroyImmediateWithUndo(item.generatedCollider);
				if (item.targetChild != null)
				{
					DestroyImmediateWithUndo(item.targetChild.gameObject);
				}
				if (item.autoGeneratedColliders != null)
				{
					MeshCollider[] autoGeneratedColliders = item.autoGeneratedColliders;
					for (int i = 0; i < autoGeneratedColliders.Length; i++)
					{
						DestroyImmediateWithUndo(autoGeneratedColliders[i]);
					}
				}
				if (item.targetAutoGeneratedChilds == null)
				{
					continue;
				}
				RigidColliderCreatorChild[] targetAutoGeneratedChilds = item.targetAutoGeneratedChilds;
				foreach (RigidColliderCreatorChild obj in targetAutoGeneratedChilds)
				{
					GameObject gameObject = obj.gameObject;
					DestroyImmediateWithUndo(obj);
					if (gameObject.transform.childCount == 0 && gameObject.GetComponents<Component>().Length == 1)
					{
						DestroyImmediateWithUndo(gameObject);
					}
				}
			}
		}

		private static bool IsDeletable(GameObject obj)
		{
			Component[] components = obj.GetComponents<Component>();
			int num = 0;
			Component[] array = components;
			foreach (Component component in array)
			{
				if (component is Transform || component is Collider || component is RigidColliderCreator || component is RigidColliderCreatorChild)
				{
					num++;
				}
			}
			return components.Length == num;
		}

		private static void DestroyImmediateWithUndo(Object obj)
		{
			if (!(obj == null))
			{
				Object.DestroyImmediate(obj);
			}
		}

		private void CreateHullMapping()
		{
			if (this.hullMapping == null)
			{
				this.hullMapping = new List<HullMapping>();
			}
			for (int num = this.hullMapping.Count - 1; num >= 0; num--)
			{
				HullMapping hullMapping = this.hullMapping[num];
				if (hullMapping == null || hullMapping.sourceHull == null || (hullMapping.generatedCollider == null && hullMapping.targetChild == null))
				{
					this.hullMapping.RemoveAt(num);
				}
			}
			foreach (Hull hull3 in paintingData.hulls)
			{
				if (IsMapped(hull3))
				{
					Collider collider = FindExistingCollider(this.hullMapping, hull3);
					bool num2 = hull3.type == HullType.ConvexHull && collider is MeshCollider;
					bool flag = hull3.type == HullType.Box && collider is BoxCollider;
					bool flag2 = hull3.type == HullType.Capsule && collider is CapsuleCollider;
					bool flag3 = hull3.type == HullType.Sphere && collider is SphereCollider;
					bool flag4 = hull3.type == HullType.Face && collider is MeshCollider;
					bool flag5 = hull3.type == HullType.FaceAsBox && collider is BoxCollider;
					bool flag6 = hull3.type == HullType.Auto && collider is MeshCollider && hull3.autoMeshes != null && hull3.autoMeshes.Length != 0;
					bool num3 = num2 || flag || flag2 || flag3 || flag4 || flag5 || flag6;
					bool flag7 = collider == null || hull3.isChildCollider == (collider.transform.parent == base.transform) || hull3.type == HullType.Auto;
					if (!(num3 && flag7))
					{
						DestroyImmediateWithUndo(collider);
						RemoveMapping(hull3);
					}
				}
			}
			List<Hull> list = new List<Hull>();
			List<Collider> list2 = new List<Collider>();
			List<RigidColliderCreatorChild> list3 = new List<RigidColliderCreatorChild>();
			foreach (Hull hull4 in paintingData.hulls)
			{
				if (!IsMapped(hull4))
				{
					list.Add(hull4);
				}
			}
			foreach (Collider item in FindLocal<Collider>())
			{
				if (!IsMapped(item))
				{
					list2.Add(item);
				}
			}
			foreach (RigidColliderCreatorChild item2 in FindLocal<RigidColliderCreatorChild>())
			{
				if (!IsMapped(item2))
				{
					list3.Add(item2);
				}
			}
			for (int num4 = list.Count - 1; num4 >= 0; num4--)
			{
				Hull hull = list[num4];
				bool flag8 = false;
				for (int num5 = list2.Count - 1; num5 >= 0; num5--)
				{
					Collider collider2 = list2[num5];
					MeshCollider meshCollider = collider2 as MeshCollider;
					BoxCollider boxCollider = collider2 as BoxCollider;
					CapsuleCollider capsuleCollider = collider2 as CapsuleCollider;
					SphereCollider sphereCollider = collider2 as SphereCollider;
					RigidColliderCreatorChild rigidColliderCreatorChild = null;
					if (collider2.transform.parent == base.transform)
					{
						rigidColliderCreatorChild = collider2.gameObject.GetComponent<RigidColliderCreatorChild>();
					}
					bool flag9 = hull.isChildCollider && collider2.transform.parent == base.transform;
					if (rigidColliderCreatorChild != null && rigidColliderCreatorChild.isAutoHull && hull.type == HullType.Auto && meshCollider != null && hull.ContainsAutoMesh(meshCollider.sharedMesh))
					{
						HullMapping hullMapping2 = FindMapping(hull);
						if (hullMapping2 == null)
						{
							hullMapping2 = new HullMapping();
							hullMapping2.sourceHull = hull;
							this.hullMapping.Add(hullMapping2);
						}
						hullMapping2.AddAutoChild(rigidColliderCreatorChild, collider2 as MeshCollider);
						rigidColliderCreatorChild.parent = this;
						list2.RemoveAt(num5);
						list3.Remove(rigidColliderCreatorChild);
						flag8 = true;
					}
					else if (flag9)
					{
						bool num6 = hull.type == HullType.Box && collider2 is BoxCollider && Approximately(hull.collisionBox.collisionBox.center, boxCollider.center) && Approximately(hull.collisionBox.collisionBox.size, boxCollider.size);
						bool flag10 = hull.type == HullType.Sphere && collider2 is SphereCollider && hull.collisionSphere != null && Approximately(hull.collisionSphere.center, sphereCollider.center) && Approximately(hull.collisionSphere.radius, sphereCollider.radius);
						bool flag11 = hull.type == HullType.Capsule && collider2 is CapsuleCollider && Approximately(hull.collisionCapsule.capsuleCenter, capsuleCollider.center) && hull.collisionCapsule.capsuleDirection == (CapsuleAxis)capsuleCollider.direction && Approximately(hull.collisionCapsule.capsuleRadius, capsuleCollider.radius) && Approximately(hull.collisionCapsule.capsuleHeight, capsuleCollider.radius);
						bool flag12 = hull.type == HullType.ConvexHull && collider2 is MeshCollider && meshCollider.sharedMesh == hull.collisionMesh;
						bool flag13 = hull.type == HullType.Face && collider2 is MeshCollider && meshCollider.sharedMesh == hull.faceCollisionMesh;
						bool flag14 = hull.type == HullType.FaceAsBox && collider2 is BoxCollider && Approximately(hull.faceBoxCenter, boxCollider.center) && Approximately(hull.faceBoxSize, boxCollider.size);
						if (num6 || flag10 || flag11 || flag12 || flag13 || flag14)
						{
							AddMapping(hull, collider2, rigidColliderCreatorChild);
							list.RemoveAt(num4);
							list2.RemoveAt(num5);
							for (int i = 0; i < list3.Count; i++)
							{
								if (list3[i] == rigidColliderCreatorChild)
								{
									list3.RemoveAt(i);
									break;
								}
							}
							break;
						}
					}
				}
				if (flag8)
				{
					list.RemoveAt(num4);
				}
			}
			for (int num7 = list.Count - 1; num7 >= 0; num7--)
			{
				if (list[num7].isChildCollider)
				{
					for (int num8 = list3.Count - 1; num8 >= 0; num8--)
					{
						RigidColliderCreatorChild child = list3[num8];
						HullMapping hullMapping3 = FindMapping(child);
						if (hullMapping3 != null && hullMapping3.sourceHull != null)
						{
							if (hullMapping3.generatedCollider == null)
							{
								RecreateChildCollider(hullMapping3);
							}
							list.RemoveAt(num7);
							list3.RemoveAt(num8);
							break;
						}
					}
				}
			}
			for (int num9 = list.Count - 1; num9 >= 0; num9--)
			{
				Hull hull2 = list[num9];
				if (hull2.isChildCollider && hull2.type == HullType.Auto)
				{
					bool flag15 = false;
					for (int num10 = list3.Count - 1; num10 >= 0; num10--)
					{
						RigidColliderCreatorChild rigidColliderCreatorChild2 = list3[num10];
						if (rigidColliderCreatorChild2.isAutoHull && rigidColliderCreatorChild2.gameObject.name.StartsWith(hull2.name))
						{
							HullMapping hullMapping4 = FindMapping(hull2);
							if (hullMapping4 == null)
							{
								hullMapping4 = new HullMapping();
								hullMapping4.sourceHull = hull2;
								this.hullMapping.Add(hullMapping4);
							}
							hullMapping4.AddAutoChild(rigidColliderCreatorChild2, null);
							list3.RemoveAt(num10);
							flag15 = true;
						}
					}
					if (flag15)
					{
						list.RemoveAt(num9);
					}
				}
			}
			foreach (HullMapping item3 in this.hullMapping)
			{
				if (item3.targetChild != null && item3.generatedCollider == null)
				{
					RecreateChildCollider(item3);
				}
			}
			foreach (HullMapping item4 in this.hullMapping)
			{
				if (item4.targetChild == null && item4.generatedCollider != null && item4.generatedCollider.transform.parent == base.transform)
				{
					RigidColliderCreatorChild rigidColliderCreatorChild3 = AddComponent<RigidColliderCreatorChild>(item4.generatedCollider.gameObject);
					rigidColliderCreatorChild3.parent = this;
					item4.targetChild = rigidColliderCreatorChild3;
				}
			}
			foreach (Hull item5 in list)
			{
				if (item5.type == HullType.Box)
				{
					CreateCollider<BoxCollider>(item5);
				}
				else if (item5.type == HullType.Sphere)
				{
					CreateCollider<SphereCollider>(item5);
				}
				else if (item5.type == HullType.ConvexHull)
				{
					CreateCollider<MeshCollider>(item5);
				}
				else if (item5.type == HullType.Face)
				{
					CreateCollider<MeshCollider>(item5);
				}
				else if (item5.type == HullType.FaceAsBox)
				{
					CreateCollider<BoxCollider>(item5);
				}
				else if (item5.type == HullType.Capsule)
				{
					CreateCollider<CapsuleCollider>(item5);
				}
			}
			foreach (Collider item6 in list2)
			{
				if (item6 == null)
				{
					continue;
				}
				if (item6.gameObject == base.gameObject)
				{
					DestroyImmediateWithUndo(item6);
					continue;
				}
				GameObject gameObject = item6.gameObject;
				DestroyImmediateWithUndo(item6);
				DestroyImmediateWithUndo(gameObject.GetComponent<RigidColliderCreatorChild>());
				if (IsDeletable(gameObject))
				{
					DestroyImmediateWithUndo(gameObject);
				}
			}
			foreach (RigidColliderCreatorChild item7 in list3)
			{
				if (!(item7 == null))
				{
					GameObject gameObject2 = item7.gameObject;
					DestroyImmediateWithUndo(item7);
					DestroyImmediateWithUndo(gameObject2.GetComponent<Collider>());
					if (IsDeletable(gameObject2))
					{
						DestroyImmediateWithUndo(gameObject2);
					}
				}
			}
		}

		private static bool Approximately(Vector3 lhs, Vector3 rhs)
		{
			if (Mathf.Approximately(lhs.x, rhs.x) && Mathf.Approximately(lhs.y, rhs.y))
			{
				return Mathf.Approximately(lhs.z, rhs.z);
			}
			return false;
		}

		private static bool Approximately(float lhs, float rhs)
		{
			return Mathf.Approximately(lhs, rhs);
		}

		private void CreateCollider<T>(Hull sourceHull) where T : Collider
		{
			if (sourceHull.isChildCollider)
			{
				GameObject obj = CreateGameObject(sourceHull.name);
				obj.transform.SetParent(base.transform, worldPositionStays: false);
				obj.transform.localPosition = Vector3.zero;
				obj.transform.localRotation = Quaternion.identity;
				obj.transform.localScale = Vector3.one;
				RigidColliderCreatorChild rigidColliderCreatorChild = AddComponent<RigidColliderCreatorChild>(obj);
				rigidColliderCreatorChild.parent = this;
				T col = AddComponent<T>(obj);
				AddMapping(sourceHull, col, rigidColliderCreatorChild);
			}
			else
			{
				T col2 = AddComponent<T>(base.gameObject);
				AddMapping(sourceHull, col2, null);
			}
		}

		private void RecreateChildCollider(HullMapping mapping)
		{
			if (mapping != null && mapping.sourceHull != null && mapping.sourceHull.isChildCollider)
			{
				if (mapping.sourceHull.type == HullType.Box)
				{
					RecreateChildCollider<BoxCollider>(mapping);
				}
				else if (mapping.sourceHull.type == HullType.Sphere)
				{
					RecreateChildCollider<SphereCollider>(mapping);
				}
				else if (mapping.sourceHull.type == HullType.ConvexHull)
				{
					RecreateChildCollider<MeshCollider>(mapping);
				}
				else if (mapping.sourceHull.type == HullType.Face)
				{
					RecreateChildCollider<MeshCollider>(mapping);
				}
				else if (mapping.sourceHull.type == HullType.FaceAsBox)
				{
					RecreateChildCollider<BoxCollider>(mapping);
				}
				else if (mapping.sourceHull.type == HullType.Capsule)
				{
					RecreateChildCollider<CapsuleCollider>(mapping);
				}
			}
		}

		private void RecreateChildCollider<T>(HullMapping mapping) where T : Collider
		{
			if (mapping.sourceHull != null && mapping.sourceHull.isChildCollider)
			{
				T generatedCollider = AddComponent<T>(mapping.targetChild.gameObject);
				mapping.generatedCollider = generatedCollider;
			}
		}

		private void UpdateCollider(Hull hull)
		{
			Collider collider = null;
			if (hull.type == HullType.Box)
			{
				BoxCollider boxCollider = FindExistingCollider(hullMapping, hull) as BoxCollider;
				boxCollider.center = hull.collisionBox.collisionBox.center;
				boxCollider.size = hull.collisionBox.collisionBox.size + (hull.enableInflation ? (Vector3.one * hull.inflationAmount) : Vector3.zero);
				if (hull.isChildCollider)
				{
					boxCollider.transform.localPosition = hull.collisionBox.boxPosition;
					boxCollider.transform.localRotation = hull.collisionBox.boxRotation;
				}
				collider = boxCollider;
			}
			else if (hull.type == HullType.Sphere)
			{
				SphereCollider sphereCollider = FindExistingCollider(hullMapping, hull) as SphereCollider;
				sphereCollider.radius = hull.collisionSphere.radius + (hull.enableInflation ? hull.inflationAmount : 0f);
				if (hull.isChildCollider)
				{
					sphereCollider.transform.localPosition = hull.collisionSphere.center;
				}
				else
				{
					sphereCollider.center = hull.collisionSphere.center;
				}
				collider = sphereCollider;
			}
			else if (hull.type == HullType.Capsule)
			{
				CapsuleCollider capsuleCollider = FindExistingCollider(hullMapping, hull) as CapsuleCollider;
				capsuleCollider.center = hull.collisionCapsule.capsuleCenter;
				capsuleCollider.direction = (int)hull.collisionCapsule.capsuleDirection;
				capsuleCollider.radius = hull.collisionCapsule.capsuleRadius;
				capsuleCollider.height = hull.collisionCapsule.capsuleHeight;
				if (hull.isChildCollider)
				{
					capsuleCollider.transform.localPosition = hull.collisionCapsule.capsulePosition;
					capsuleCollider.transform.localRotation = hull.collisionCapsule.capsuleRotation;
				}
				collider = capsuleCollider;
			}
			else if (hull.type == HullType.ConvexHull)
			{
				MeshCollider obj = FindExistingCollider(hullMapping, hull) as MeshCollider;
				obj.sharedMesh = hull.collisionMesh;
				obj.convex = true;
				obj.cookingOptions &= ~MeshColliderCookingOptions.EnableMeshCleaning;
				collider = obj;
			}
			else if (hull.type == HullType.Face)
			{
				MeshCollider obj2 = FindExistingCollider(hullMapping, hull) as MeshCollider;
				obj2.sharedMesh = hull.faceCollisionMesh;
				obj2.convex = true;
				collider = obj2;
			}
			else if (hull.type == HullType.FaceAsBox)
			{
				BoxCollider boxCollider2 = FindExistingCollider(hullMapping, hull) as BoxCollider;
				boxCollider2.size = hull.faceBoxSize + (hull.enableInflation ? (Vector3.one * hull.inflationAmount) : Vector3.zero);
				if (hull.isChildCollider)
				{
					boxCollider2.transform.localPosition = hull.faceBoxCenter;
					boxCollider2.transform.localRotation = hull.faceAsBoxRotation;
				}
				else
				{
					boxCollider2.center = hull.faceBoxCenter;
				}
				collider = boxCollider2;
			}
			else
			{
				_ = hull.type;
				_ = 5;
			}
			if (collider != null)
			{
				collider.material = hull.material;
				collider.isTrigger = hull.isTrigger;
				if (hull.isChildCollider)
				{
					collider.gameObject.name = hull.name;
				}
			}
		}

		public void SetAllTypes(HullType newType)
		{
			foreach (Hull hull in paintingData.hulls)
			{
				hull.type = newType;
			}
		}

		public void SetAllMaterials(PhysicMaterial newMaterial)
		{
			foreach (Hull hull in paintingData.hulls)
			{
				hull.material = newMaterial;
			}
		}

		public void SetAllAsChild(bool isChild)
		{
			foreach (Hull hull in paintingData.hulls)
			{
				hull.isChildCollider = isChild;
			}
		}

		public void SetAllAsTrigger(bool isTrigger)
		{
			foreach (Hull hull in paintingData.hulls)
			{
				hull.isTrigger = isTrigger;
			}
		}

		private List<T> FindLocal<T>() where T : Component
		{
			List<T> list = new List<T>();
			list.AddRange(base.gameObject.GetComponents<T>());
			for (int i = 0; i < base.transform.childCount; i++)
			{
				list.AddRange(base.transform.GetChild(i).GetComponents<T>());
			}
			return list;
		}

		private bool IsMapped(Hull hull)
		{
			if (hullMapping == null)
			{
				return false;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.sourceHull == hull)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsMapped(Collider col)
		{
			if (hullMapping == null)
			{
				return false;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.generatedCollider == col)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsMapped(RigidColliderCreatorChild child)
		{
			if (hullMapping == null)
			{
				return false;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.targetChild == child)
				{
					return true;
				}
			}
			return false;
		}

		private void AddMapping(Hull hull, Collider col, RigidColliderCreatorChild painterChild)
		{
			HullMapping item = new HullMapping
			{
				sourceHull = hull,
				generatedCollider = col,
				targetChild = painterChild
			};
			hullMapping.Add(item);
		}

		private void RemoveMapping(Hull hull)
		{
			for (int i = 0; i < hullMapping.Count; i++)
			{
				if (hullMapping[i].sourceHull == hull)
				{
					hullMapping.RemoveAt(i);
					break;
				}
			}
		}

		private HullMapping FindMapping(RigidColliderCreatorChild child)
		{
			if (hullMapping == null)
			{
				return null;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.targetChild == child)
				{
					return item;
				}
			}
			return null;
		}

		private HullMapping FindMapping(Hull hull)
		{
			if (hullMapping == null)
			{
				return null;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.sourceHull == hull)
				{
					return item;
				}
			}
			return null;
		}

		public Hull FindSourceHull(RigidColliderCreatorChild child)
		{
			if (hullMapping == null)
			{
				return null;
			}
			foreach (HullMapping item in hullMapping)
			{
				if (item.targetChild == child)
				{
					return item.sourceHull;
				}
				if (item.targetAutoGeneratedChilds == null)
				{
					continue;
				}
				RigidColliderCreatorChild[] targetAutoGeneratedChilds = item.targetAutoGeneratedChilds;
				for (int i = 0; i < targetAutoGeneratedChilds.Length; i++)
				{
					if (targetAutoGeneratedChilds[i] == child)
					{
						return item.sourceHull;
					}
				}
			}
			return null;
		}

		private static Collider FindExistingCollider(List<HullMapping> mappings, Hull hull)
		{
			foreach (HullMapping mapping in mappings)
			{
				if (mapping.sourceHull == hull)
				{
					return mapping.generatedCollider;
				}
			}
			return null;
		}

		private void CreateAutoHulls(Hull hull, Mesh[] autoHulls)
		{
			if (hull.type != HullType.Auto)
			{
				return;
			}
			HullMapping hullMapping = FindMapping(hull);
			if (hullMapping == null)
			{
				hullMapping = new HullMapping();
				hullMapping.sourceHull = hull;
				this.hullMapping.Add(hullMapping);
			}
			Mesh[] autoMeshes = hull.autoMeshes;
			List<MeshCollider> list = new List<MeshCollider>();
			if (hullMapping.targetAutoGeneratedChilds != null)
			{
				for (int i = 0; i < hullMapping.targetAutoGeneratedChilds.Length; i++)
				{
					if (hullMapping.autoGeneratedColliders != null && i < hullMapping.autoGeneratedColliders.Length)
					{
						list.Add(hullMapping.autoGeneratedColliders[i]);
						continue;
					}
					MeshCollider meshCollider = hullMapping.targetAutoGeneratedChilds[i].gameObject.AddComponent<MeshCollider>();
					meshCollider.convex = true;
					list.Add(meshCollider);
				}
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				bool flag = list[num].transform != base.transform;
				if (flag != (bool)base.transform && hull.isChildCollider)
				{
					if (flag)
					{
						Object.DestroyImmediate(list[num].gameObject);
					}
					else
					{
						Object.DestroyImmediate(list[num]);
					}
					list.RemoveAt(num);
				}
			}
			for (int j = 0; j < autoMeshes.Length; j++)
			{
				Mesh sharedMesh = autoMeshes[j];
				MeshCollider meshCollider2;
				if (j < list.Count)
				{
					meshCollider2 = list[j];
				}
				else if (hull.isChildCollider)
				{
					GameObject obj = CreateGameObject("New child");
					obj.transform.SetParent(base.transform, worldPositionStays: false);
					RigidColliderCreatorChild rigidColliderCreatorChild = obj.AddComponent<RigidColliderCreatorChild>();
					rigidColliderCreatorChild.parent = this;
					rigidColliderCreatorChild.isAutoHull = true;
					meshCollider2 = obj.AddComponent<MeshCollider>();
					list.Add(meshCollider2);
				}
				else
				{
					meshCollider2 = base.gameObject.AddComponent<MeshCollider>();
					list.Add(meshCollider2);
				}
				meshCollider2.sharedMesh = sharedMesh;
				meshCollider2.convex = true;
				meshCollider2.isTrigger = hull.isTrigger;
				meshCollider2.material = hull.material;
			}
			if (hull.isChildCollider)
			{
				for (int k = 0; k < list.Count; k++)
				{
					list[k].gameObject.name = $"{hull.name}.{k + 1}";
				}
			}
			List<RigidColliderCreatorChild> list2 = new List<RigidColliderCreatorChild>();
			foreach (MeshCollider item in list)
			{
				list2.Add(item.GetComponent<RigidColliderCreatorChild>());
			}
			hullMapping.autoGeneratedColliders = list.ToArray();
			hullMapping.targetAutoGeneratedChilds = list2.ToArray();
		}

		private static GameObject CreateGameObject(string goName)
		{
			return new GameObject(goName);
		}

		private static T AddComponent<T>(GameObject targetObj) where T : Component
		{
			return targetObj.AddComponent<T>();
		}

		private void OnDrawGizmos()
		{
		}
	}
}
